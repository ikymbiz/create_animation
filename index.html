<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GenAIお絵かきパレード(安定版)</title>
    <script src="https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.5/dist/bundle.js"></script>
    <style>
        :root { --primary: #7e57c2; --danger: #ef5350; --success: #26a69a; }
        body { margin: 0; overflow: hidden; background: #e0f7fa; background-size: cover; background-position: center; font-family: sans-serif; touch-action: none; }
        #ui-layer { position: absolute; top: 15px; left: 15px; z-index: 100; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); width: 260px; }
        .section { border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 10px; }
        input, button { width: 100%; padding: 10px; margin-top: 5px; border-radius: 8px; border: 1px solid #ddd; box-sizing: border-box; }
        button { cursor: pointer; font-weight: bold; color: white; border: none; }
        .btn-ai { background: var(--primary); }
        .btn-save { background: var(--success); }
        .btn-clear { background: var(--danger); }
        #status { font-size: 0.75rem; color: #d32f2f; margin: 5px 0; min-height: 1.2em; word-break: break-all; }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h3>GenAIお絵かき</h3>
    <div class="section">
        <input type="password" id="apiKey" placeholder="Gemini API Key">
        <button class="btn-save" id="saveKeyBtn">キーを保存</button>
    </div>
    <div class="section">
        <div id="status">ライブラリ読み込み中...</div>
        <input type="file" id="upload" accept="image/*" multiple>
        <button class="btn-ai" id="aiBgBtn">AI背景を生成</button>
    </div>
    <button class="btn-clear" id="clearBtn">リセット</button>
</div>

<canvas id="stage"></canvas>

<script>
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    const statusText = document.getElementById('status');
    const apiKeyInput = document.getElementById('apiKey');

    let drawings = [];
    let dragTarget = null;
    let dragOffsetX, dragOffsetY;

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        apiKeyInput.value = localStorage.getItem('gemini_api_key') || '';
        statusText.textContent = "準備完了（絵を選んでね）";
    }
    window.addEventListener('resize', init);
    init();

    // --- 背景削除処理 ---
    async function processImage(file) {
        statusText.textContent = "AI解析を開始...";
        try {
            // ライブラリが存在するかチェック
            if (typeof imglyRemoveBackground === 'undefined') {
                throw new Error("AIライブラリの読み込みに失敗しています");
            }

            // AIによる切り抜き
            const blob = await imglyRemoveBackground.removeBackground(file);
            const url = URL.createObjectURL(blob);
            
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve({ img, url });
                img.src = url;
            });
        } catch (e) {
            console.error(e);
            statusText.textContent = "AI失敗：簡易処理に切り替えます";
            // 失敗した場合は、簡易的な「白を消す」処理へ
            return await fallbackProcess(file);
        }
    }

    // AIがダメだった時のバックアップ（白消し）
    async function fallbackProcess(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const c = document.createElement('canvas');
                    const cx = c.getContext('2d');
                    c.width = img.width; c.height = img.height;
                    cx.drawImage(img, 0, 0);
                    const data = cx.getImageData(0,0,c.width,c.height);
                    for(let i=0; i<data.data.length; i+=4) {
                        if(data.data[i]>200 && data.data[i+1]>200 && data.data[i+2]>200) data.data[i+3]=0;
                    }
                    cx.putImageData(data,0,0);
                    const newImg = new Image();
                    newImg.onload = () => resolve({ img: newImg, url: e.target.result });
                    newImg.src = c.toDataURL();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    class Drawing {
        constructor(imgInfo, originalSrc) {
            this.img = imgInfo.img;
            this.originalSrc = originalSrc;
            const ratio = this.img.height / this.img.width;
            this.width = Math.min(canvas.width, canvas.height) * 0.25;
            this.height = this.width * ratio;
            this.x = Math.random() * (canvas.width - this.width);
            this.y = Math.random() * (canvas.height - this.height);
            this.dx = (Math.random() - 0.5) * 3;
            this.dy = (Math.random() - 0.5) * 3;
            this.isDragging = false;
        }
        update() {
            if (this.isDragging) return;
            if (this.x + this.width > canvas.width || this.x < 0) this.dx *= -1;
            if (this.y + this.height > canvas.height || this.y < 0) this.dy *= -1;
            this.x += this.dx; this.y += this.dy;
        }
        draw() { ctx.drawImage(this.img, this.x, this.y, this.width, this.height); }
        contains(px, py) {
            return px >= this.x && px <= this.x + this.width && py >= this.y && py <= this.y + this.height;
        }
    }

    upload.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        for (const file of files) {
            const processed = await processImage(file);
            if (processed) {
                drawings.push(new Drawing(processed, processed.url));
                statusText.textContent = "追加完了！";
            }
        }
        upload.value = "";
    });

    // --- インタラクション ---
    function getPos(e) {
        const t = e.touches ? e.touches[0] : e;
        return { x: t.clientX, y: t.clientY };
    }
    canvas.addEventListener('mousedown', (e) => {
        const pos = getPos(e);
        for (let i = drawings.length - 1; i >= 0; i--) {
            if (drawings[i].contains(pos.x, pos.y)) {
                dragTarget = drawings[i];
                dragTarget.isDragging = true;
                dragOffsetX = pos.x - dragTarget.x;
                dragOffsetY = pos.y - dragTarget.y;
                drawings.push(drawings.splice(i, 1)[0]);
                break;
            }
        }
    });
    window.addEventListener('mousemove', (e) => {
        if (!dragTarget) return;
        const pos = getPos(e);
        dragTarget.x = pos.x - dragOffsetX;
        dragTarget.y = pos.y - dragOffsetY;
    });
    window.addEventListener('mouseup', () => { if(dragTarget) dragTarget.isDragging = false; dragTarget = null; });
    canvas.addEventListener('dblclick', (e) => {
        const pos = getPos(e);
        drawings = drawings.filter(d => !d.contains(pos.x, pos.y));
    });

    // --- Gemini API ---
    document.getElementById('saveKeyBtn').addEventListener('click', () => {
        localStorage.setItem('gemini_api_key', apiKeyInput.value);
        alert('キーを保存しました');
    });

    document.getElementById('aiBgBtn').addEventListener('click', async () => {
        const key = apiKeyInput.value;
        if (!key || drawings.length === 0) return alert("キーと絵が必要です");
        
        statusText.textContent = "AIが背景を考え中...";
        try {
            const last = drawings[drawings.length - 1];
            const base64 = last.originalSrc.split(',')[1];
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [
                        { text: "Choose one word for a background: forest, ocean, space, desert, or city." },
                        { inline_data: { mime_type: "image/png", data: base64 } }
                    ]}]
                })
            });
            const data = await response.json();
            const keyword = data.candidates[0].content.parts[0].text.trim().toLowerCase().replace(/[^a-z]/g, '');
            document.body.style.backgroundImage = `url('https://loremflickr.com/1280/720/${keyword}')`;
            statusText.textContent = `背景テーマ：${keyword}`;
        } catch (e) {
            statusText.textContent = "背景生成に失敗しました";
        }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
        drawings = [];
        document.body.style.backgroundImage = 'none';
        statusText.textContent = "リセットしました";
    });

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawings.forEach(d => { d.update(); d.draw(); });
        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>
</html>
