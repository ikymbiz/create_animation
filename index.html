<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GenAIお絵かきパレード</title>
    <script src="https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.5/dist/bundle.js"></script>
    <style>
        :root { --primary: #7e57c2; --danger: #ef5350; --success: #26a69a; }
        body { margin: 0; overflow: hidden; background: #e0f7fa cover center; font-family: sans-serif; touch-action: none; }
        #ui-layer { position: absolute; top: 15px; left: 15px; z-index: 100; background: rgba(255, 255, 255, 0.9); padding: 20px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); max-width: 280px; }
        .section { border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 10px; }
        input, button { width: 100%; padding: 10px; margin-top: 5px; border-radius: 8px; border: none; box-sizing: border-box; }
        button { cursor: pointer; font-weight: bold; color: white; }
        .btn-ai { background: var(--primary); }
        .btn-save { background: var(--success); }
        .btn-clear { background: var(--danger); }
        #status { font-size: 0.8rem; color: #d32f2f; font-weight: bold; }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="ui-layer">
    <h3>GenAIお絵かき</h3>
    <div class="section">
        <input type="password" id="apiKey" placeholder="Gemini API Key">
        <button class="btn-save" id="saveKeyBtn">キーを保存</button>
    </div>
    <div class="section">
        <p id="status">準備OK</p>
        <input type="file" id="upload" accept="image/*" multiple>
        <button class="btn-ai" id="aiBgBtn">AI背景を生成</button>
    </div>
    <button class="btn-clear" id="clearBtn">リセット</button>
</div>

<canvas id="stage"></canvas>

<script>
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    const statusText = document.getElementById('status');
    const apiKeyInput = document.getElementById('apiKey');

    let drawings = [];
    let dragTarget = null;
    let dragOffsetX, dragOffsetY;

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        apiKeyInput.value = localStorage.getItem('gemini_api_key') || '';
    }
    window.addEventListener('resize', init);
    init();

    // --- AIによる背景削除処理 ---
    async function processImageAI(file) {
        statusText.textContent = "AIが切り抜き中...";
        try {
            // imglyのAIモデルを使用して背景を削除
            const blob = await imglyRemoveBackground(file);
            const url = URL.createObjectURL(blob);
            
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve({ img, url });
                img.src = url;
            });
        } catch (e) {
            console.error(e);
            statusText.textContent = "AI切り抜き失敗";
            return null;
        }
    }

    class Drawing {
        constructor(imgInfo, originalSrc) {
            this.img = imgInfo.img;
            this.originalSrc = originalSrc;
            const ratio = this.img.height / this.img.width;
            this.width = Math.min(canvas.width, canvas.height) * 0.25;
            this.height = this.width * ratio;
            this.x = Math.random() * (canvas.width - this.width);
            this.y = Math.random() * (canvas.height - this.height);
            this.dx = (Math.random() - 0.5) * 4;
            this.dy = (Math.random() - 0.5) * 4;
            this.isDragging = false;
        }
        update() {
            if (this.isDragging) return;
            if (this.x + this.width > canvas.width || this.x < 0) this.dx *= -1;
            if (this.y + this.height > canvas.height || this.y < 0) this.dy *= -1;
            this.x += this.dx; this.y += this.dy;
        }
        draw() { ctx.drawImage(this.img, this.x, this.y, this.width, this.height); }
        contains(px, py) {
            return px >= this.x && px <= this.x + this.width && py >= this.y && py <= this.y + this.height;
        }
    }

    upload.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        for (const file of files) {
            const originalSrc = await new Promise(r => {
                const fr = new FileReader();
                fr.onload = () => r(fr.result);
                fr.readAsDataURL(file);
            });
            
            const aiProcessed = await processImageAI(file);
            if (aiProcessed) {
                drawings.push(new Drawing(aiProcessed, originalSrc));
                statusText.textContent = "完了！";
            }
        }
        upload.value = "";
    });

    // --- インタラクション ---
    function getPos(e) {
        const t = e.touches ? e.touches[0] : e;
        return { x: t.clientX, y: t.clientY };
    }
    canvas.addEventListener('mousedown', (e) => {
        const pos = getPos(e);
        for (let i = drawings.length - 1; i >= 0; i--) {
            if (drawings[i].contains(pos.x, pos.y)) {
                dragTarget = drawings[i];
                dragTarget.isDragging = true;
                dragOffsetX = pos.x - dragTarget.x;
                dragOffsetY = pos.y - dragTarget.y;
                drawings.push(drawings.splice(i, 1)[0]);
                break;
            }
        }
    });
    window.addEventListener('mousemove', (e) => {
        if (!dragTarget) return;
        const pos = getPos(e);
        dragTarget.x = pos.x - dragOffsetX;
        dragTarget.y = pos.y - dragOffsetY;
    });
    window.addEventListener('mouseup', () => { if(dragTarget) dragTarget.isDragging = false; dragTarget = null; });
    canvas.addEventListener('dblclick', (e) => {
        const pos = getPos(e);
        drawings = drawings.filter(d => !d.contains(pos.x, pos.y));
    });

    // --- Gemini API背景生成 ---
    document.getElementById('saveKeyBtn').addEventListener('click', () => {
        localStorage.setItem('gemini_api_key', apiKeyInput.value);
        alert('キーを保存しました');
    });

    document.getElementById('aiBgBtn').addEventListener('click', async () => {
        const key = apiKeyInput.value;
        if (!key || drawings.length === 0) return alert("キーと絵が必要です");
        
        statusText.textContent = "AI背景を考え中...";
        try {
            const last = drawings[drawings.length - 1];
            const base64 = last.originalSrc.split(',')[1];
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [
                        { text: "What setting would this drawing look best in? Answer with one English noun (e.g., 'jungle', 'mars', 'underwater')." },
                        { inline_data: { mime_type: "image/png", data: base64 } }
                    ]}]
                })
            });
            const data = await response.json();
            const keyword = data.candidates[0].content.parts[0].text.trim().toLowerCase();
            document.body.style.backgroundImage = `url('https://loremflickr.com/1920/1080/${keyword}')`;
            statusText.textContent = `背景：${keyword}`;
        } catch (e) {
            statusText.textContent = "AI背景生成失敗";
        }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
        drawings = [];
        document.body.style.backgroundImage = 'none';
    });

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawings.forEach(d => { d.update(); d.draw(); });
        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>
</html>
