<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini AI Parade</title>
    <style>
        :root { --primary: #3f51b5; --accent: #ff4081; --bg: #f5f5f5; }
        body { margin: 0; overflow: hidden; background: var(--bg); background-size: cover; background-position: center; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #ui { position: absolute; top: 15px; left: 15px; z-index: 100; background: rgba(255,255,255,0.9); padding: 18px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); width: 280px; }
        .box { margin-bottom: 12px; }
        input, button { width: 100%; padding: 12px; margin-top: 6px; border-radius: 10px; border: 1px solid #ddd; box-sizing: border-box; font-size: 14px; }
        button { cursor: pointer; border: none; font-weight: bold; color: white; transition: 0.2s; }
        .btn-save { background: #4caf50; }
        .btn-main { background: var(--primary); }
        .btn-clear { background: #666; }
        #status { font-size: 12px; color: var(--accent); margin-top: 8px; font-weight: bold; }
        canvas { display: block; }
        /* キャラクターの名前ラベル */
        .label { position: absolute; background: white; padding: 2px 8px; border-radius: 10px; font-size: 10px; pointer-events: none; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    </style>
</head>
<body>

<div id="ui">
    <h3 style="margin:0; color:var(--primary);">Geminiお絵かき</h3>
    
    <div class="box">
        <input type="password" id="apiKey" placeholder="Gemini API Key">
        <button class="btn-save" id="saveKeyBtn">キーを保存</button>
    </div>

    <div class="box">
        <div id="status">準備OK：絵を選んでね</div>
        <input type="file" id="upload" accept="image/*" multiple>
        <button class="btn-main" id="aiBtn" style="margin-top:10px;">Geminiにすべておまかせ</button>
    </div>

    <button class="btn-clear" id="clearBtn">リセット</button>
</div>

<canvas id="stage"></canvas>

<script>
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    const statusText = document.getElementById('status');
    const apiKeyInput = document.getElementById('apiKey');

    let drawings = [];
    let dragTarget = null;
    let dragOffsetX, dragOffsetY;

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        apiKeyInput.value = localStorage.getItem('gemini_api_key') || '';
    }
    window.addEventListener('resize', init);
    init();

    // --- JavaScriptによる高度な背景削除（AIのヒントなしでも動くように最適化） ---
    function removeBackground(img) {
        const c = document.createElement('canvas');
        const cx = c.getContext('2d');
        c.width = img.width;
        c.height = img.height;
        cx.drawImage(img, 0, 0);
        
        const imageData = cx.getImageData(0, 0, c.width, c.height);
        const data = imageData.data;

        // 輝度ベースの削除アルゴリズム（紙の白さを判定）
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            // 明るさが一定以上（白っぽい）なら透明にする
            const brightness = (r + g + b) / 3;
            if (brightness > 200) { 
                data[i + 3] = 0;
            }
        }
        cx.putImageData(imageData, 0, 0);
        return c;
    }

    class Drawing {
        constructor(imgCanvas, originalSrc, info) {
            this.img = imgCanvas;
            this.src = originalSrc;
            this.name = info.name || "ななしさん";
            const ratio = this.img.height / this.img.width;
            this.width = Math.min(canvas.width, canvas.height) * 0.25;
            this.height = this.width * ratio;
            this.x = Math.random() * (canvas.width - this.width);
            this.y = Math.random() * (canvas.height - this.height);
            this.dx = (Math.random() - 0.5) * 4;
            this.dy = (Math.random() - 0.5) * 4;
            this.isDragging = false;
        }
        update() {
            if (this.isDragging) return;
            if (this.x + this.width > canvas.width || this.x < 0) this.dx *= -1;
            if (this.y + this.height > canvas.height || this.y < 0) this.dy *= -1;
            this.x += this.dx; this.y += this.dy;
        }
        draw() {
            ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
            // 名前を表示
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.fillRect(this.x, this.y - 20, this.name.length * 10 + 10, 18);
            ctx.fillStyle = "#333";
            ctx.font = "bold 12px sans-serif";
            ctx.fillText(this.name, this.x + 5, this.y - 6);
        }
        contains(px, py) {
            return px >= this.x && px <= this.x + this.width && py >= this.y && py <= this.y + this.height;
        }
    }

    upload.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        statusText.textContent = "画像を読み込み中...";
        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => {
                    const cleanCanvas = removeBackground(img);
                    drawings.push(new Drawing(cleanCanvas, ev.target.result, {name: "???"}));
                    statusText.textContent = "追加完了！";
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    // --- Gemini API: 背景と名前を決定 ---
    document.getElementById('aiBtn').addEventListener('click', async () => {
        const key = apiKeyInput.value;
        if (!key || drawings.length === 0) return alert("キーと絵が必要です");
        
        statusText.textContent = "Geminiが世界を創っています...";
        try {
            const last = drawings[drawings.length - 1];
            const base64 = last.src.split(',')[1];
            
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [
                        { text: "この絵を分析して、以下の情報をJSON形式で返してください。1.このキャラの名前(name) 2.似合う背景の英単語1つ(bg) 3.その理由を日本語で15文字以内(desc)" },
                        { inline_data: { mime_type: "image/png", data: base64 } }
                    ]}]
                })
            });
            const data = await response.json();
            const text = data.candidates[0].content.parts[0].text;
            // JSON部分を抽出
            const jsonMatch = text.match(/\{.*\}/s);
            const res = JSON.parse(jsonMatch[0]);

            last.name = res.name;
            document.body.style.backgroundImage = `url('https://source.unsplash.com/featured/?${res.bg}')`;
            statusText.textContent = `背景：${res.bg} (${res.desc})`;
        } catch (e) {
            console.error(e);
            statusText.textContent = "Geminiとの通信に失敗しました";
        }
    });

    // --- インタラクション ---
    function getPos(e) {
        const t = e.touches ? e.touches[0] : e;
        return { x: t.clientX, y: t.clientY };
    }
    canvas.addEventListener('mousedown', (e) => {
        const pos = getPos(e);
        for (let i = drawings.length - 1; i >= 0; i--) {
            if (drawings[i].contains(pos.x, pos.y)) {
                dragTarget = drawings[i];
                dragTarget.isDragging = true;
                dragOffsetX = pos.x - dragTarget.x;
                dragOffsetY = pos.y - dragTarget.y;
                drawings.push(drawings.splice(i, 1)[0]);
                break;
            }
        }
    });
    window.addEventListener('mousemove', (e) => {
        if (!dragTarget) return;
        const pos = getPos(e);
        dragTarget.x = pos.x - dragOffsetX;
        dragTarget.y = pos.y - dragOffsetY;
    });
    window.addEventListener('mouseup', () => { if(dragTarget) dragTarget.isDragging = false; dragTarget = null; });
    canvas.addEventListener('dblclick', (e) => {
        const pos = getPos(e);
        drawings = drawings.filter(d => !d.contains(pos.x, pos.y));
    });

    document.getElementById('saveKeyBtn').addEventListener('click', () => {
        localStorage.setItem('gemini_api_key', apiKeyInput.value);
        alert('キーを保存しました');
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
        drawings = [];
        document.body.style.backgroundImage = 'none';
        statusText.textContent = "リセット完了";
    });

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawings.forEach(d => { d.update(); d.draw(); });
        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>
</html>
