<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gemini Drawing Extractor</title>
    <style>
        :root { --primary: #4285f4; --accent: #ea4335; --bg: #f8f9fa; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: sans-serif; touch-action: none; }
        #ui { position: absolute; top: 15px; left: 15px; z-index: 100; background: rgba(255,255,255,0.95); padding: 18px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); width: 280px; }
        input, button { width: 100%; padding: 12px; margin-top: 8px; border-radius: 10px; border: 1px solid #ddd; box-sizing: border-box; }
        button { cursor: pointer; border: none; font-weight: bold; color: white; background: var(--primary); }
        .btn-save { background: #34a853; margin-bottom: 10px; }
        #status { font-size: 12px; color: #555; margin-top: 8px; font-weight: bold; }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="ui">
    <h3 style="margin:0; color:var(--primary);">主役キャラ抽出</h3>
    <input type="password" id="apiKey" placeholder="Gemini API Key">
    <button class="btn-save" id="saveKeyBtn">キーを保存</button>
    
    <div id="status">画像を選んでね</div>
    <input type="file" id="upload" accept="image/*" multiple>
    <button id="aiBtn">Geminiで主役を抽出</button>
    <button style="background:#666;" onclick="location.reload()">リセット</button>
</div>

<canvas id="stage"></canvas>

<script>
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    const upload = document.getElementById('upload');
    const statusText = document.getElementById('status');
    const apiKeyInput = document.getElementById('apiKey');

    let drawings = [];
    let dragTarget = null;

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        apiKeyInput.value = localStorage.getItem('gemini_api_key') || '';
    }
    window.addEventListener('resize', init);
    init();

    // 背景除去（白っぽい部分を透明にする）
    function removeWhite(imgCanvas) {
        const cx = imgCanvas.getContext('2d');
        const imageData = cx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
            if (brightness > 210) data[i+3] = 0; // 白背景を透明化
        }
        cx.putImageData(imageData, 0, 0);
        return imgCanvas;
    }

    class Drawing {
        constructor(img, originalDataUrl) {
            this.img = img;
            this.src = originalDataUrl;
            this.x = Math.random() * (canvas.width - 200);
            this.y = Math.random() * (canvas.height - 200);
            this.width = 200;
            this.height = (img.height / img.width) * 200;
        }
        draw() {
            ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
        }
        contains(px, py) {
            return px >= this.x && px <= this.x + this.width && py >= this.y && py <= this.y + this.height;
        }
    }

    upload.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files);
        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => {
                    const tempC = document.createElement('canvas');
                    tempC.width = img.width; tempC.height = img.height;
                    tempC.getContext('2d').drawImage(img, 0, 0);
                    drawings.push(new Drawing(tempC, ev.target.result));
                    statusText.textContent = "読み込み完了。抽出ボタンを押して！";
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    document.getElementById('aiBtn').addEventListener('click', async () => {
        const key = apiKeyInput.value;
        if (!key || drawings.length === 0) return alert("APIキーと画像が必要です");
        
        statusText.textContent = "AIが主役を探しています...";

        for (let d of drawings) {
            try {
                const base64 = d.src.split(',')[1];
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [
                            { text: "この画像からメインとなる絵（キャラクターなど）を1つだけ検出し、その範囲を [ymin, xmin, ymax, xmax] の数値配列で返してください。座標は0から1000の範囲で。JSON形式で出力して。" },
                            { inline_data: { mime_type: "image/png", data: base64 } }
                        ]}],
                        generationConfig: { response_mime_type: "application/json" }
                    })
                });
                
                const data = await response.json();
                const resText = data.candidates[0].content.parts[0].text;
                const box = JSON.parse(resText); 
                const coords = Array.isArray(box) ? box : Object.values(box)[0]; // [ymin, xmin, ymax, xmax]

                // 切り抜き処理
                const img = new Image();
                img.src = d.src;
                await img.decode();

                const [ymin, xmin, ymax, xmax] = coords;
                const sx = (xmin / 1000) * img.width;
                const sy = (ymin / 1000) * img.height;
                const sw = ((xmax - xmin) / 1000) * img.width;
                const sh = ((ymax - ymin) / 1000) * img.height;

                const cropC = document.createElement('canvas');
                cropC.width = sw; cropC.height = sh;
                cropC.getContext('2d').drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
                
                d.img = removeWhite(cropC);
                d.height = (sh / sw) * d.width;
                statusText.textContent = "抽出成功！";
            } catch (e) {
                console.error(e);
                statusText.textContent = "エラー発生";
            }
        }
    });

    // 保存処理
    document.getElementById('saveKeyBtn').addEventListener('click', () => {
        localStorage.setItem('gemini_api_key', apiKeyInput.value);
        alert('キーを保存しました');
    });

    // ドラッグ操作
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        dragTarget = drawings.findLast(d => d.contains(x, y));
    });
    window.addEventListener('mousemove', (e) => {
        if (dragTarget) { dragTarget.x = e.clientX - 100; dragTarget.y = e.clientY - 100; }
    });
    window.addEventListener('mouseup', () => dragTarget = null);

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawings.forEach(d => d.draw());
        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>
</html>
